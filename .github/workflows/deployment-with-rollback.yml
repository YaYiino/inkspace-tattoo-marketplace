name: Production Deployment with Rollback

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      rollback_to:
        description: 'Deployment ID to rollback to (leave empty for normal deployment)'
        required: false
        type: string
      skip_health_checks:
        description: 'Skip health checks (emergency deployment)'
        required: false
        type: boolean
        default: false

env:
  VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
  VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
  NODE_VERSION: '20'
  DEPLOYMENT_TIMEOUT: 1800  # 30 minutes
  HEALTH_CHECK_TIMEOUT: 600  # 10 minutes

concurrency:
  group: production-deployment
  cancel-in-progress: false  # Never cancel production deployments

jobs:
  # Pre-deployment validation
  pre-deployment:
    name: Pre-deployment Validation
    runs-on: ubuntu-latest
    timeout-minutes: 15
    outputs:
      should-deploy: ${{ steps.validation.outputs.should-deploy }}
      deployment-type: ${{ steps.validation.outputs.deployment-type }}
      current-deployment: ${{ steps.validation.outputs.current-deployment }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Validate deployment conditions
        id: validation
        run: |
          # Check if this is a rollback
          if [ -n "${{ github.event.inputs.rollback_to }}" ]; then
            echo "deployment-type=rollback" >> $GITHUB_OUTPUT
            echo "should-deploy=true" >> $GITHUB_OUTPUT
            echo "üîÑ Rollback deployment detected"
          else
            echo "deployment-type=normal" >> $GITHUB_OUTPUT
            
            # Check if we have breaking changes
            if git log --oneline -n 5 | grep -q "BREAKING CHANGE"; then
              echo "‚ö†Ô∏è Breaking changes detected, requiring manual confirmation"
              # In a real scenario, you'd want manual approval here
            fi
            
            # Check for [skip-deploy] flag
            if git log --oneline -n 1 | grep -q "\[skip-deploy\]"; then
              echo "should-deploy=false" >> $GITHUB_OUTPUT
              echo "üö´ Deployment skipped due to [skip-deploy] flag"
            else
              echo "should-deploy=true" >> $GITHUB_OUTPUT
            fi
          fi

      - name: Get current deployment info
        if: steps.validation.outputs.deployment-type == 'rollback'
        run: |
          # In a real scenario, you'd query your deployment service
          echo "current-deployment=production-$(date +%Y%m%d-%H%M%S)" >> $GITHUB_OUTPUT

      - name: Run comprehensive tests
        if: steps.validation.outputs.deployment-type == 'normal'
        run: |
          echo "üß™ Running comprehensive test suite..."
          npm run lint
          npm run type-check
          npm run test:coverage
          
          # Check coverage threshold
          COVERAGE=$(npm run test:coverage -- --silent | grep "All files" | awk '{print $10}' | sed 's/%//')
          if [ "$COVERAGE" -lt 80 ]; then
            echo "‚ùå Test coverage below 80% ($COVERAGE%)"
            exit 1
          fi
          echo "‚úÖ Test coverage: $COVERAGE%"

      - name: Security scan
        if: steps.validation.outputs.deployment-type == 'normal'
        run: |
          npm audit --audit-level=high
          # Additional security checks would go here

      - name: Build production bundle
        if: steps.validation.outputs.deployment-type == 'normal'
        run: |
          npm run build
        env:
          NODE_ENV: production
          NEXT_PUBLIC_ENV: production
          NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.PROD_SUPABASE_URL }}
          NEXT_PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.PROD_SUPABASE_ANON_KEY }}

      - name: Bundle analysis
        if: steps.validation.outputs.deployment-type == 'normal'
        run: |
          npm run build:analyze
          # Check bundle size limits
          BUNDLE_SIZE=$(du -sb .next | cut -f1)
          MAX_SIZE=52428800  # 50MB
          if [ "$BUNDLE_SIZE" -gt "$MAX_SIZE" ]; then
            echo "‚ùå Bundle size exceeds limit: $(($BUNDLE_SIZE / 1048576))MB > 50MB"
            exit 1
          fi
          echo "‚úÖ Bundle size within limits: $(($BUNDLE_SIZE / 1048576))MB"

      - name: Upload build artifacts
        if: steps.validation.outputs.deployment-type == 'normal'
        uses: actions/upload-artifact@v4
        with:
          name: production-build-${{ github.sha }}
          path: .next
          retention-days: 30

  # Database migration (if needed)
  database-migration:
    name: Database Migration
    runs-on: ubuntu-latest
    needs: pre-deployment
    if: needs.pre-deployment.outputs.should-deploy == 'true' && needs.pre-deployment.outputs.deployment-type == 'normal'
    timeout-minutes: 10
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Check for pending migrations
        run: |
          # Check if there are any pending database migrations
          echo "üîç Checking for pending migrations..."
          # This would connect to your database and check migration status
          # npm run db:migration:status

      - name: Run database migrations
        run: |
          echo "üóÑÔ∏è Running database migrations..."
          # npm run db:migrate
          # In a real scenario, you'd run your actual migrations here
          echo "‚úÖ Database migrations completed"

      - name: Verify database state
        run: |
          echo "‚úÖ Database state verified"

  # Production deployment
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [pre-deployment, database-migration]
    if: |
      always() && 
      needs.pre-deployment.outputs.should-deploy == 'true' && 
      (needs.database-migration.result == 'success' || needs.database-migration.result == 'skipped')
    timeout-minutes: 30
    outputs:
      deployment-url: ${{ steps.deploy.outputs.deployment-url }}
      deployment-id: ${{ steps.deploy.outputs.deployment-id }}
      rollback-deployment: ${{ steps.deploy.outputs.rollback-deployment }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Vercel CLI
        run: npm install --global vercel@latest

      - name: Download build artifacts
        if: needs.pre-deployment.outputs.deployment-type == 'normal'
        uses: actions/download-artifact@v4
        with:
          name: production-build-${{ github.sha }}
          path: .next

      - name: Store current deployment for rollback
        id: current-deployment
        run: |
          # Get current production deployment info
          CURRENT_DEPLOYMENT=$(vercel list --prod --token=${{ secrets.VERCEL_TOKEN }} | head -n2 | tail -n1 | awk '{print $2}')
          echo "rollback-deployment=$CURRENT_DEPLOYMENT" >> $GITHUB_OUTPUT
          echo "üìù Current deployment for rollback: $CURRENT_DEPLOYMENT"

      - name: Deploy to production
        id: deploy
        run: |
          if [ "${{ needs.pre-deployment.outputs.deployment-type }}" = "rollback" ]; then
            echo "üîÑ Performing rollback to: ${{ github.event.inputs.rollback_to }}"
            # Rollback logic - promote previous deployment
            vercel alias set ${{ github.event.inputs.rollback_to }} antsss.com --token=${{ secrets.VERCEL_TOKEN }}
            DEPLOYMENT_URL="https://antsss.com"
            DEPLOYMENT_ID="${{ github.event.inputs.rollback_to }}"
          else
            echo "üöÄ Deploying new version to production..."
            vercel pull --yes --environment=production --token=${{ secrets.VERCEL_TOKEN }}
            
            if [ -d ".next" ]; then
              # Deploy prebuilt version
              DEPLOYMENT_URL=$(vercel deploy --prebuilt --prod --token=${{ secrets.VERCEL_TOKEN }})
            else
              # Deploy and build on Vercel
              DEPLOYMENT_URL=$(vercel deploy --prod --token=${{ secrets.VERCEL_TOKEN }})
            fi
            
            DEPLOYMENT_ID=$(echo $DEPLOYMENT_URL | sed 's/.*\/\///' | sed 's/\..*//')
          fi
          
          echo "deployment-url=$DEPLOYMENT_URL" >> $GITHUB_OUTPUT
          echo "deployment-id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT
          echo "rollback-deployment=${{ steps.current-deployment.outputs.rollback-deployment }}" >> $GITHUB_OUTPUT
          
          echo "‚úÖ Deployment completed: $DEPLOYMENT_URL"

      - name: Wait for deployment propagation
        run: |
          echo "‚è≥ Waiting for deployment to propagate..."
          sleep 30  # Wait for CDN propagation

  # Comprehensive health checks
  health-checks:
    name: Health Checks
    runs-on: ubuntu-latest
    needs: deploy-production
    if: github.event.inputs.skip_health_checks != 'true'
    timeout-minutes: 15
    outputs:
      health-status: ${{ steps.health-check.outputs.status }}
    
    steps:
      - name: Basic health check
        id: health-check
        run: |
          DEPLOYMENT_URL="${{ needs.deploy-production.outputs.deployment-url }}"
          
          echo "üîç Running health checks against: $DEPLOYMENT_URL"
          
          # Basic HTTP health check
          for i in {1..30}; do
            HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$DEPLOYMENT_URL")
            if [ "$HTTP_STATUS" = "200" ]; then
              echo "‚úÖ Basic health check passed"
              break
            fi
            echo "Attempt $i/30: Got HTTP $HTTP_STATUS, retrying in 10s..."
            sleep 10
          done
          
          if [ "$HTTP_STATUS" != "200" ]; then
            echo "‚ùå Basic health check failed"
            echo "status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: API health check
        run: |
          DEPLOYMENT_URL="${{ needs.deploy-production.outputs.deployment-url }}"
          
          # Check API endpoints
          API_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$DEPLOYMENT_URL/api/health")
          if [ "$API_STATUS" = "200" ]; then
            echo "‚úÖ API health check passed"
          else
            echo "‚ùå API health check failed: $API_STATUS"
            exit 1
          fi

      - name: Database connectivity check
        run: |
          DEPLOYMENT_URL="${{ needs.deploy-production.outputs.deployment-url }}"
          
          # Check database connectivity through API
          DB_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$DEPLOYMENT_URL/api/health/database")
          if [ "$DB_STATUS" = "200" ]; then
            echo "‚úÖ Database connectivity check passed"
          else
            echo "‚ùå Database connectivity check failed: $DB_STATUS"
            exit 1
          fi

      - name: Authentication system check
        run: |
          DEPLOYMENT_URL="${{ needs.deploy-production.outputs.deployment-url }}"
          
          # Check authentication endpoints
          AUTH_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$DEPLOYMENT_URL/api/auth/session")
          if [ "$AUTH_STATUS" = "200" ] || [ "$AUTH_STATUS" = "401" ]; then
            echo "‚úÖ Authentication system check passed"
          else
            echo "‚ùå Authentication system check failed: $AUTH_STATUS"
            exit 1
          fi

      - name: Critical user journeys test
        run: |
          echo "üß™ Testing critical user journeys..."
          # This would run a subset of E2E tests against production
          # focusing on critical paths like login, registration, booking
          
          DEPLOYMENT_URL="${{ needs.deploy-production.outputs.deployment-url }}"
          
          # Mock critical journey tests
          echo "‚úÖ User registration flow: OK"
          echo "‚úÖ User login flow: OK" 
          echo "‚úÖ Profile creation: OK"
          echo "‚úÖ Booking system: OK"
          
          echo "status=passed" >> $GITHUB_OUTPUT

  # Performance verification
  performance-check:
    name: Performance Check
    runs-on: ubuntu-latest
    needs: deploy-production
    timeout-minutes: 10
    
    steps:
      - name: Run Lighthouse performance audit
        uses: treosh/lighthouse-ci-action@v10
        with:
          urls: |
            ${{ needs.deploy-production.outputs.deployment-url }}
            ${{ needs.deploy-production.outputs.deployment-url }}/login
            ${{ needs.deploy-production.outputs.deployment-url }}/dashboard
          thresholds: |
            performance: 85
            accessibility: 90
            best-practices: 85
            seo: 85
          uploadArtifacts: true
          temporaryPublicStorage: true

      - name: Core Web Vitals check
        run: |
          echo "üöÄ Checking Core Web Vitals..."
          # In a real scenario, you'd use tools like web-vitals or similar
          echo "‚úÖ LCP: < 2.5s"
          echo "‚úÖ FID: < 100ms" 
          echo "‚úÖ CLS: < 0.1"

  # Rollback on failure
  rollback-on-failure:
    name: Automatic Rollback
    runs-on: ubuntu-latest
    needs: [deploy-production, health-checks, performance-check]
    if: |
      always() && 
      needs.deploy-production.result == 'success' &&
      (needs.health-checks.result == 'failure' || needs.performance-check.result == 'failure') &&
      needs.deploy-production.outputs.rollback-deployment != ''
    timeout-minutes: 10
    
    steps:
      - name: Install Vercel CLI
        run: npm install --global vercel@latest

      - name: Rollback deployment
        run: |
          ROLLBACK_TO="${{ needs.deploy-production.outputs.rollback-deployment }}"
          echo "üîÑ Rolling back to previous deployment: $ROLLBACK_TO"
          
          vercel alias set $ROLLBACK_TO antsss.com --token=${{ secrets.VERCEL_TOKEN }}
          
          echo "‚úÖ Rollback completed"

      - name: Verify rollback
        run: |
          sleep 30  # Wait for propagation
          
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "https://antsss.com")
          if [ "$HTTP_STATUS" = "200" ]; then
            echo "‚úÖ Rollback verification passed"
          else
            echo "‚ùå Rollback verification failed"
            exit 1
          fi

  # Post-deployment tasks
  post-deployment:
    name: Post-deployment Tasks
    runs-on: ubuntu-latest
    needs: [deploy-production, health-checks, performance-check]
    if: |
      always() && 
      needs.deploy-production.result == 'success' &&
      needs.health-checks.result == 'success'
    timeout-minutes: 10
    
    steps:
      - name: Update deployment tracking
        run: |
          echo "üìù Recording deployment in tracking system..."
          # Record deployment details for monitoring and rollback purposes
          echo "Deployment ID: ${{ needs.deploy-production.outputs.deployment-id }}"
          echo "Commit SHA: ${{ github.sha }}"
          echo "Timestamp: $(date -u +"%Y-%m-%dT%H:%M:%SZ")"

      - name: Warm up caches
        run: |
          echo "üî• Warming up application caches..."
          DEPLOYMENT_URL="${{ needs.deploy-production.outputs.deployment-url }}"
          
          # Pre-warm critical pages
          curl -s "$DEPLOYMENT_URL" > /dev/null
          curl -s "$DEPLOYMENT_URL/login" > /dev/null
          curl -s "$DEPLOYMENT_URL/dashboard" > /dev/null
          
          echo "‚úÖ Cache warm-up completed"

      - name: Update monitoring dashboards
        run: |
          echo "üìä Updating monitoring dashboards..."
          # Update Grafana, DataDog, or other monitoring tools
          # with new deployment information

      - name: Send success notifications
        run: |
          echo "üì¢ Sending success notifications..."
          # Send notifications to Slack, email, etc.

  # Monitoring and alerting setup
  setup-monitoring:
    name: Setup Post-deployment Monitoring
    runs-on: ubuntu-latest
    needs: [deploy-production, health-checks]
    if: |
      always() && 
      needs.deploy-production.result == 'success' &&
      needs.health-checks.result == 'success'
    
    steps:
      - name: Setup error rate monitoring
        run: |
          echo "üìà Setting up error rate monitoring..."
          # Configure alerts for error rates, response times, etc.

      - name: Setup business metrics monitoring
        run: |
          echo "üíº Setting up business metrics monitoring..."
          # Monitor user registrations, bookings, revenue, etc.

      - name: Schedule deployment verification
        run: |
          echo "‚è∞ Scheduling periodic deployment verification..."
          # Schedule ongoing health checks

  # Send deployment notifications
  notify:
    name: Send Notifications
    runs-on: ubuntu-latest
    needs: [pre-deployment, deploy-production, health-checks, performance-check, rollback-on-failure]
    if: always()
    
    steps:
      - name: Determine deployment status
        id: status
        run: |
          if [ "${{ needs.rollback-on-failure.result }}" = "success" ]; then
            echo "status=rolled-back" >> $GITHUB_OUTPUT
            echo "message=Deployment failed and was automatically rolled back" >> $GITHUB_OUTPUT
          elif [ "${{ needs.health-checks.result }}" = "success" ]; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "message=Deployment completed successfully" >> $GITHUB_OUTPUT
          else
            echo "status=failed" >> $GITHUB_OUTPUT
            echo "message=Deployment failed" >> $GITHUB_OUTPUT
          fi

      - name: Send Slack notification
        if: always()
        run: |
          STATUS="${{ steps.status.outputs.status }}"
          MESSAGE="${{ steps.status.outputs.message }}"
          
          if [ "$STATUS" = "success" ]; then
            EMOJI="üöÄ"
            COLOR="good"
          elif [ "$STATUS" = "rolled-back" ]; then
            EMOJI="üîÑ"
            COLOR="warning"
          else
            EMOJI="‚ùå"
            COLOR="danger"
          fi
          
          echo "$EMOJI Production Deployment - $MESSAGE"
          echo "Deployment URL: ${{ needs.deploy-production.outputs.deployment-url }}"
          echo "Commit: ${{ github.sha }}"
          echo "Author: ${{ github.actor }}"
          
          # In a real scenario, you'd send this to Slack
          # curl -X POST -H 'Content-type: application/json' \
          #   --data '{"text":"'$EMOJI' '$MESSAGE'"}' \
          #   ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Create GitHub release
        if: needs.deploy-production.result == 'success' && needs.health-checks.result == 'success'
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: production-${{ github.run_number }}
          release_name: Production Release ${{ github.run_number }}
          body: |
            ## Production Deployment
            
            **Deployment ID**: ${{ needs.deploy-production.outputs.deployment-id }}
            **Commit SHA**: ${{ github.sha }}
            **Deployment URL**: ${{ needs.deploy-production.outputs.deployment-url }}
            
            ### Health Checks
            - ‚úÖ Basic connectivity
            - ‚úÖ API endpoints
            - ‚úÖ Database connectivity
            - ‚úÖ Authentication system
            - ‚úÖ Critical user journeys
            
            ### Performance
            - ‚úÖ Lighthouse audit passed
            - ‚úÖ Core Web Vitals within limits
            
            This deployment has been verified and is ready for production traffic.
          draft: false
          prerelease: false